#!/bin/bash

##############################################################################
# CSS Optimizer Script
# 自动提取项目中使用的 Remixicon 图标和 Animate.css 动画
# 生成精简版 CSS 文件并优化字体文件
##############################################################################

set -e  # 遇到错误立即退出

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 项目路径
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
LAYOUTS_DIR="${PROJECT_ROOT}/themes/zozo/layouts"
CUSTOM_LAYOUTS_DIR="${PROJECT_ROOT}/layouts"
STATIC_CSS_DIR="${PROJECT_ROOT}/themes/zozo/static/css"
STATIC_FONTS_DIR="${PROJECT_ROOT}/themes/zozo/static/fonts"
REMIXICON_SOURCE="${STATIC_CSS_DIR}/remixicon.css"
ANIMATE_SOURCE="${STATIC_CSS_DIR}/animate.min.css"
REMIXICON_OUTPUT="${STATIC_CSS_DIR}/remixicon-custom.css"
ANIMATE_OUTPUT="${STATIC_CSS_DIR}/animate-custom.css"
FONT_SOURCE="${STATIC_FONTS_DIR}/remixicon.woff2"
FONT_OUTPUT="${STATIC_FONTS_DIR}/remixicon-custom.woff2"

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}  CSS & Font 优化脚本${NC}"
echo -e "${BLUE}========================================${NC}"
echo ""

##############################################################################
# 1. 提取 Remixicon 图标
##############################################################################

echo -e "${YELLOW}[1/6] 扫描项目中使用的 Remixicon 图标...${NC}"

# 优先从 hugo_stats.json 提取图标类名（如果存在）
HUGO_STATS_FILE="${PROJECT_ROOT}/hugo_stats.json"
if [ -f "$HUGO_STATS_FILE" ]; then
    echo -e "${BLUE}  → 从 hugo_stats.json 提取图标类名${NC}"
    REMIXICON_CLASSES=$(grep -o '"ri-[a-z0-9-]*"' "$HUGO_STATS_FILE" | \
        tr -d '"' | \
        sort -u | \
        grep -v '^ri-$' || true)
else
    # 回退方案：从 HTML 模板中提取
    echo -e "${BLUE}  → 从 HTML 模板提取图标类名${NC}"
    REMIXICON_CLASSES=$(find "${LAYOUTS_DIR}" "${CUSTOM_LAYOUTS_DIR}" -type f -name "*.html" 2>/dev/null | \
        xargs grep -oh 'class="[^"]*ri-[^"]*"' 2>/dev/null | \
        grep -o 'ri-[a-z0-9-]*' | \
        sort -u | \
        grep -v '^ri-$' || true)
fi

if [ -z "$REMIXICON_CLASSES" ]; then
    echo -e "${RED}  ✗ 未找到任何 Remixicon 图标${NC}"
    exit 1
fi

# 统计数量
ICON_COUNT=$(echo "$REMIXICON_CLASSES" | wc -l | tr -d ' ')
echo -e "${GREEN}  ✓ 找到 ${ICON_COUNT} 个图标:${NC}"
echo "$REMIXICON_CLASSES" | sed 's/^/    - /'
echo ""

##############################################################################
# 2. 生成 remixicon-custom.css
##############################################################################

echo -e "${YELLOW}[2/6] 生成 remixicon-custom.css...${NC}"

# 检查源文件
if [ ! -f "$REMIXICON_SOURCE" ]; then
    echo -e "${RED}  ✗ 源文件不存在: $REMIXICON_SOURCE${NC}"
    exit 1
fi

# 提取原始文件大小
ORIGINAL_SIZE=$(du -h "$REMIXICON_SOURCE" | cut -f1)

# 生成文件头
cat > "$REMIXICON_OUTPUT" << 'EOF'
/*
* Remix Icon - Custom Build
* Auto-generated by optimize-css.sh
* Only includes icons actually used in the theme
*/
EOF

# 提取 @font-face 声明
echo "" >> "$REMIXICON_OUTPUT"
sed -n '/^@font-face/,/^}/p' "$REMIXICON_SOURCE" >> "$REMIXICON_OUTPUT"

# 提取基础样式
echo "" >> "$REMIXICON_OUTPUT"
sed -n '/^\[class\^="ri-"\]/,/^}/p' "$REMIXICON_SOURCE" >> "$REMIXICON_OUTPUT"

# 添加注释
echo "" >> "$REMIXICON_OUTPUT"
echo "/* Only include the ${ICON_COUNT} icons actually used */" >> "$REMIXICON_OUTPUT"

# 提取每个图标的 CSS 规则
for icon in $REMIXICON_CLASSES; do
    grep "^\\.${icon}:before" "$REMIXICON_SOURCE" >> "$REMIXICON_OUTPUT" 2>/dev/null || {
        echo -e "${RED}  ✗ 警告: 未找到图标 ${icon} 的定义${NC}"
    }
done

# 计算优化后的大小
OPTIMIZED_SIZE=$(du -h "$REMIXICON_OUTPUT" | cut -f1)
echo -e "${GREEN}  ✓ 生成成功: ${REMIXICON_OUTPUT}${NC}"
echo -e "    原始大小: ${ORIGINAL_SIZE} → 优化后: ${OPTIMIZED_SIZE}"
echo ""

##############################################################################
# 3. 提取字体文件中使用的字符 (Unicode)
##############################################################################

echo -e "${YELLOW}[3/6] 提取图标对应的 Unicode 字符...${NC}"

# 从 CSS 中提取 content 值 (Unicode码点)
UNICODE_LIST=""
for icon in $REMIXICON_CLASSES; do
    unicode=$(grep "^\\.${icon}:before" "$REMIXICON_SOURCE" | grep -o 'content: "\\[^"]*"' | sed 's/content: "\\//;s/"//g' || true)
    if [ -n "$unicode" ]; then
        UNICODE_LIST="${UNICODE_LIST}${unicode},"
    fi
done

# 移除最后的逗号
UNICODE_LIST=${UNICODE_LIST%,}

if [ -z "$UNICODE_LIST" ]; then
    echo -e "${RED}  ✗ 未能提取 Unicode 字符${NC}"
else
    echo -e "${GREEN}  ✓ 提取到 ${ICON_COUNT} 个字符码点${NC}"
    echo -e "    Unicode: ${UNICODE_LIST}"
fi
echo ""

##############################################################################
# 4. 优化字体文件 (使用 pyftsubset)
##############################################################################

echo -e "${YELLOW}[4/6] 优化字体文件...${NC}"

# 检查是否安装 fonttools
if ! command -v pyftsubset &> /dev/null; then
    echo -e "${YELLOW}  ! pyftsubset 未安装，正在尝试安装 fonttools...${NC}"
    if command -v pip3 &> /dev/null; then
        pip3 install --user --quiet --break-system-packages fonttools brotli 2>&1 | grep -v "Requirement already satisfied" || true
    elif command -v pip &> /dev/null; then
        pip install --user --quiet --break-system-packages fonttools brotli 2>&1 | grep -v "Requirement already satisfied" || true
    else
        echo -e "${RED}  ✗ 无法安装 fonttools${NC}"
        echo -e "${YELLOW}  ⚠ 跳过字体优化，CSS 优化已完成${NC}"
        SKIP_FONT_OPTIMIZATION=true
    fi

    # 重新检查是否安装成功
    if ! command -v pyftsubset &> /dev/null; then
        # 尝试使用完整路径
        PYFTSUBSET_PATH="$HOME/Library/Python/$(python3 --version 2>&1 | grep -o '[0-9]\.[0-9]*')/bin/pyftsubset"
        if [ -f "$PYFTSUBSET_PATH" ]; then
            export PATH="$HOME/Library/Python/$(python3 --version 2>&1 | grep -o '[0-9]\.[0-9]*')/bin:$PATH"
        else
            echo -e "${RED}  ✗ fonttools 安装失败或未找到${NC}"
            echo -e "${YELLOW}  ⚠ 跳过字体优化，CSS 优化已完成${NC}"
            SKIP_FONT_OPTIMIZATION=true
        fi
    fi
fi

if [ "$SKIP_FONT_OPTIMIZATION" != "true" ] && [ -n "$UNICODE_LIST" ]; then
    # 检查源字体文件
    if [ ! -f "$FONT_SOURCE" ]; then
        echo -e "${RED}  ✗ 字体文件不存在: $FONT_SOURCE${NC}"
    else
        FONT_ORIGINAL_SIZE=$(du -h "$FONT_SOURCE" | cut -f1)

        # 使用 pyftsubset 提取子集
        echo -e "${BLUE}  → 正在生成精简字体文件...${NC}"

        pyftsubset "$FONT_SOURCE" \
            --unicodes="$UNICODE_LIST" \
            --flavor=woff2 \
            --output-file="$FONT_OUTPUT" \
            --layout-features='*' \
            --no-hinting \
            2>&1 | grep -v "WARNING" || true

        if [ -f "$FONT_OUTPUT" ]; then
            FONT_OPTIMIZED_SIZE=$(du -h "$FONT_OUTPUT" | cut -f1)
            echo -e "${GREEN}  ✓ 字体优化成功: ${FONT_OUTPUT}${NC}"
            echo -e "    原始大小: ${FONT_ORIGINAL_SIZE} → 优化后: ${FONT_OPTIMIZED_SIZE}"

            # 更新 CSS 中的字体引用
            echo -e "${BLUE}  → 更新 CSS 字体引用...${NC}"
            sed -i.bak 's|url("/fonts/remixicon.woff2|url("/fonts/remixicon-custom.woff2|g' "$REMIXICON_OUTPUT"
            rm -f "${REMIXICON_OUTPUT}.bak"
            echo -e "${GREEN}  ✓ CSS 字体引用已更新${NC}"
        else
            echo -e "${RED}  ✗ 字体优化失败${NC}"
        fi
    fi
else
    echo -e "${YELLOW}  ⚠ 跳过字体优化${NC}"
fi
echo ""

##############################################################################
# 5. 提取 Animate.css 动画
##############################################################################

echo -e "${YELLOW}[5/6] 扫描项目中使用的 Animate.css 动画...${NC}"

# 优先从 hugo_stats.json 提取动画类名（如果存在）
if [ -f "$HUGO_STATS_FILE" ]; then
    echo -e "${BLUE}  → 从 hugo_stats.json 提取动画类名${NC}"
    ANIMATION_NAMES=$(grep -o '"animate__[a-zA-Z]*"' "$HUGO_STATS_FILE" | \
        tr -d '"' | \
        grep -v '^animate__animated$' | \
        sed 's/animate__//' | \
        sort -u || true)
else
    # 回退方案：从 HTML 模板中提取
    echo -e "${BLUE}  → 从 HTML 模板提取动画类名${NC}"
    ANIMATION_NAMES=$(find "${LAYOUTS_DIR}" "${CUSTOM_LAYOUTS_DIR}" -type f -name "*.html" 2>/dev/null | \
        xargs grep -oh 'animate__[a-zA-Z]*' 2>/dev/null | \
        grep -v '^animate__animated$' | \
        sed 's/animate__//' | \
        sort -u || true)
fi

if [ -z "$ANIMATION_NAMES" ]; then
    echo -e "${RED}  ✗ 未找到任何 Animate.css 动画${NC}"
    exit 1
fi

# 统计数量
ANIM_COUNT=$(echo "$ANIMATION_NAMES" | wc -l | tr -d ' ')
echo -e "${GREEN}  ✓ 找到 ${ANIM_COUNT} 个动画:${NC}"
echo "$ANIMATION_NAMES" | sed 's/^/    - animate__/'
echo ""

##############################################################################
# 6. 生成 animate-custom.css（手动处理压缩CSS）
##############################################################################

echo -e "${YELLOW}[6/6] 生成 animate-custom.css...${NC}"

# 检查源文件
if [ ! -f "$ANIMATE_SOURCE" ]; then
    echo -e "${RED}  ✗ 源文件不存在: $ANIMATE_SOURCE${NC}"
    exit 1
fi

# 提取原始文件大小
ANIMATE_ORIGINAL_SIZE=$(du -h "$ANIMATE_SOURCE" | cut -f1)

# 手动生成精简版 animate.css
cat > "$ANIMATE_OUTPUT" << 'EOF'
/*
* Animate.css - Custom Build
* Auto-generated by optimize-css.sh
* Only includes animations actually used
*/
.animate__animated {
  -webkit-animation-duration: 1s;
  animation-duration: 1s;
  -webkit-animation-fill-mode: both;
  animation-fill-mode: both;
}

EOF

# 为每个动画生成 CSS（手动编写常用动画）
for anim in $ANIMATION_NAMES; do
    case $anim in
        fadeInDown)
            cat >> "$ANIMATE_OUTPUT" << 'EOF'
@-webkit-keyframes fadeInDown {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}

@keyframes fadeInDown {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}

.animate__fadeInDown {
  -webkit-animation-name: fadeInDown;
  animation-name: fadeInDown;
}

EOF
            ;;
        fadeIn)
            cat >> "$ANIMATE_OUTPUT" << 'EOF'
@-webkit-keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.animate__fadeIn {
  -webkit-animation-name: fadeIn;
  animation-name: fadeIn;
}

EOF
            ;;
        *)
            echo -e "${YELLOW}  ! 警告: 未实现动画 ${anim}, 请手动添加${NC}"
            ;;
    esac
done

# 计算优化后的大小
ANIMATE_OPTIMIZED_SIZE=$(du -h "$ANIMATE_OUTPUT" | cut -f1)
echo -e "${GREEN}  ✓ 生成成功: ${ANIMATE_OUTPUT}${NC}"
echo -e "    原始大小: ${ANIMATE_ORIGINAL_SIZE} → 优化后: ${ANIMATE_OPTIMIZED_SIZE}"
echo ""

##############################################################################
# 总结
##############################################################################

echo -e "${BLUE}========================================${NC}"
echo -e "${GREEN}✓ CSS & Font 优化完成!${NC}"
echo -e "${BLUE}========================================${NC}"
echo ""
echo -e "统计信息:"
echo -e "  • Remixicon 图标: ${ICON_COUNT} 个"
echo -e "  • Animate.css 动画: ${ANIM_COUNT} 个"
echo ""
echo -e "文件大小:"
echo -e "  • remixicon.css:        ${ORIGINAL_SIZE} → ${OPTIMIZED_SIZE}"
if [ -n "$FONT_OPTIMIZED_SIZE" ]; then
    echo -e "  • remixicon.woff2:      ${FONT_ORIGINAL_SIZE} → ${FONT_OPTIMIZED_SIZE}"
fi
echo -e "  • animate.min.css:      ${ANIMATE_ORIGINAL_SIZE} → ${ANIMATE_OPTIMIZED_SIZE}"
echo ""
echo -e "${YELLOW}提示:${NC}"
echo -e "  1. 请运行 'hugo server' 预览效果"
echo -e "  2. 确认无误后运行 'hugo' 重新构建站点"
echo -e "  3. 提交更改: git add . && git commit -m 'chore: 优化 CSS 和字体资源'"
echo ""
